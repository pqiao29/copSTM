#' Fitting copula-based Multivariate spatio-temporal model
#'
#' @param x A matrix of covariates generated by \code{make_data} or \code{sim_data}. 
#' @param y A vector of count data response. 
#' @param cor_type A character string, one of "sp", "mv" and "both". 
#'  Specifically, if "sp" (short for spatial), only spatial correlations of the same group from neighbouring tiles are captured; 
#'  if "mv" (short for multivariate), only the correlations between groups in the same tile are captured; 
#'  if "both", the model computes "sp" and "mv", as well as between-group correlation from neighbouring tiles.
#' @param K The number of groups.
#' @param n An integer number, the image is tilled into n*n grids.  
#' @param maxit Maximum number of iterations of maximum likelihood estimation. 
#' @param B The number of bootstrap samples to be generated for computing the standard error of parameters. (Must be set if \code{std_err == TRUE}) 
#' @param Message_prog Logical, if TRUE, prints messages indicating progress. (Suggest on if long computational time is expected)
#' @param std_err Logical, if TRUE returns bootstrapped standard errors of parameters. 
#' @param eps Convergence threshold for maximum likelihood estimation. 
#'
#' @return A list with components
#' \itemize{
#' \item \code{likelihood:}   Maximized log-likelihood. 
#' \item \code{coefficients:} A list of parameter estimates: 
#'                     \itemize{
#'                       \item \code{intercepts:}  A separate intercept for each group,
#'                        \item \code{main_effects:}  Regression parameters indicating temporal impacts on growth between groups,
#'                        \item \code{correlations:} Spatial and multivariate correlations of observations at the same time point.}
#' \item \code{standard_error:}  A list of estimated standard errors, in the same format as \code{coefficients}. Returned only if \code{std_err == TRUE}. 
#' }
#'
#' @examples
#' ### Simulated data (cor_type = "both", no standard error)
#' K <- 2
#' n <- 10
#' t_size <- 10
#' true_beta <- c(-1, 1, 0.5, -0.5, 0, 1)
#' true_rho <- c(-0.3, 0, 0.3, 0)
#' sim_dat <- sim_data(10, n, K, t_size, true_beta, true_rho, "both")
#'  # in the same form returned by make_data
#' est_cop_sim <- copSTM(sim_dat$covariates, sim_dat$response, "both", K, n, maxit = 50,
#' std_err = FALSE) # without standard error
#' print(est_cop_sim$coefficients)
#' 
#' ### With simulated data (cor_type = "mv", with standard error)
#' true_rho <- 0.3
#' sim_dat <- sim_data(10, n, K, t_size, true_beta, true_rho, "mv")
#' est_cop_sim <- copSTM(sim_dat$covariates, sim_dat$response, "mv", K, n, maxit = 50,
#' std_err = TRUE, B = 30, Message_prog = TRUE)
#' print(est_cop_sim$coefficients)
#' print(est_cop_sim$standard_error)
#' 
#' ### with example data (expected around 40s)
#' \dontrun{
#' data("cell_growth_data") 
#' n <- 25
#' dat <- make_data(cell_growth_data, n)
#' K <- dat$K
#' est_cop_real <- copSTM(dat$covariates, dat$response, "both", dat$K, n, maxit = 50)
#' print(est_cop_real$coefficients$main_effects)
#' cor0 <- matrix(NA, K, K)
#' cor1 <- matrix(NA, K, K)
#' diag(cor0) <- 1
#' diag(cor1) <- est_cop_real$coefficients$correlations[1:dat$K]
#' ind_r = K + 1
#' for(i in 1:(K - 1)){
#'   for(j in (i + 1):K){
#'     cor0[i, j] <- est_cop_real$coefficients$correlations[ind_r]
#'     ind_r = ind_r + 1
#'   }
#' }
#' for(i in 1:(K - 1)){
#'   for(j in (i + 1):K){
#'     cor1[i, j] <- est_cop_real$coefficients$correlations[ind_r]
#'     ind_r = ind_r + 1
#'   }
#' }
#' print("correlation in the same tile: ")
#' print(round(cor0, 3))
#' print("correlation in neighbouring tiles: ")
#' print(round(cor1, 3))
#' }
#' 
#' @seealso \code{\link{sim_data}}, \code{\link{make_data}}

copSTM <- function(x, y, cor_type = "both", K, n, maxit, eps = 0.1, std_err = F, B = 0, Message_prog = F){
  
  if(std_err && !(B > 0)){
    print("positive B required")
    return(NULL)
  }
  
  if(cor_type == "sp") ct <- 1
  if(cor_type == "mv") ct <- 2 
  if(cor_type == "both") ct <- 3 
  res <- copSTM_cpp(x, y, ct, K, n, maxit, eps, std_err, B, Message_prog)
  
  regres_par <- matrix(res$main, (K + 1), K)
  ret_est <- list("intercept" = regres_par[1, ], "main_effects" = regres_par[-1, ], 
                  "correlations" = res$rho)
  
  if(std_err){
    
    se <- sqrt(res$std_err)
    se_main <- matrix(se[1:(K * (K + 1))], (K + 1), K)
    ret_se <- list("intercept" = se_main[1, ],
                   "main_effects" = se_main[-1, ], 
                   "correlations" = se[-(1:(K * (K + 1)))])
    
    return(list( "coefficients" = ret_est,
                 "likelihood" = res$likelihood, 
                 "standard_error" = ret_se))
  }else{
    return(list("likelihood" = res$likelihood, 
                "coefficients" = ret_est))
  }
}


#' Model selection of copula-base multivariate spatio-temporal model
#' 
#' \code{copSTModelSelect} performs variable selection via Gibbs samplling on model \code{copSTM} using CL-BIC. (NEED REF) 
#'
#' @param x A matrix of covariates generated by \code{make_data} or \code{sim_data}. 
#' @param y A vector of count data response.  
#' @param cor_type A character string, one of "sp", "mv" and "both". 
#'  Specifically, if "sp" (short for spatial), only spatial correlations of the same group from neighbouring tiles are captured; 
#'  if "mv" (short for multivariate), only the correlations between groups in the same tile are captured; 
#'  if "both", the model computes "sp" and "mv", as well as between-group correlation from neighbouring tiles.
#' @param K The number of groups.
#' @param n An integer number, the image is tilled into n*n grids.  
#' @param ModelCnt The number of models to be generated via Gibbs samplling.  
#' @param B  The number of bootstrap samples to be generated for computing the penalty in CL-BIC and standard error of parameters.
#' @param maxit1 The maximum number of iterations of maximum likelihood estimation (for full model).
#' @param maxit2 The maximum number of iterations of maximum likelihood estimation (for sub-models),
#'  expect to be much smaller than maxit1, since submodels take estimates from the full model as initial values.
#' @param add_penalty A tunning parameter to enforce sparsity. The larger this value is, the more favorable a sparse model becomes. 
#' @param Message_prog Logical, if TRUE, prints messages indicating progress. (Suggest on if long computational time is expected)
#' @param Message_res Logical, if TRUE, prints the top 5 most frequently generated models. 
#' @param std_err Logical, if TRUE returns bootstrapped standard errors of parameters. 
#' @param eps Convergence threshold for maximum likelihood estimation. 
#'
#' @return A list with components
#' \itemize{
#' \item \code{likelihood:}   Maximized log-likelihood. 
#' \item \code{coefficients:} A list of parameter estimates: 
#'                     \itemize{
#'                       \item \code{intercepts:}  A separate intercept for each group,
#'                        \item \code{main_effects:}  Regression parameters indicating temporal impacts on growth between groups,
#'                        \item \code{correlations:} Spatial and multivariate correlations of observations at the same time point.}
#' \item \code{selected_model:}  A binary vector with 1 indicating selected variables and 0 otherwise.
#' \item \code{standard_error:}  A list of estimated standard errors, in the same format as \code{coefficient}. Returned only if \code{std_err == TRUE}. 
#' }
#' 
#' @examples
#' \dontrun{
#' set.seed(444)
#' K <- 2  # number of groups
#' n <- 10 # (squared root of) number of tiles
#' t_size <- 10 # number of time points
#' true_beta <- c(-1, 1, 0.5, -0.5, 0, 1)
#' true_rho <- c(-0.3, 0, 0.3, 0)
#' sim_dat <- sim_data(10, n, K, t_size, true_beta, true_rho, "both") 
#' # generate data in the same form returned by make_data
#' 
#' MdCnt <- 50
#' B <- 20 
#' gm <- 0.5  
#' set.seed(444)
#' start <- Sys.time()  # expected less than 2 mins 
#' select_est <- copSTModelSelect(sim_dat$covariates, sim_dat$response, "both", K = K, n = n, 
#'                                ModelCnt = MdCnt, B = B, add_penalty = gm,
#'                                Message_prog = TRUE, Message_res = TRUE, std_err = TRUE, eps = 0.1)
#' finish <- Sys.time()
#' print(finish - start)
#' as.numeric(as.logical(c(true_beta, true_rho)))
#' print(select_est$coefficients)
#' print(select_est$standard_error)
#' }
#' 
#' @seealso \code{\link{sim_data}}, \code{\link{make_data}}


copSTModelSelect <- function(x, y, cor_type, K, n, ModelCnt, B, maxit1 = 50, maxit2 = 10, 
                             add_penalty = 0, Message_prog = TRUE, Message_res = TRUE, 
                             std_err = TRUE, eps = 0.1){
  
  if(cor_type == "sp") ct <- 1
  if(cor_type == "mv") ct <- 2 
  if(cor_type == "both") ct <- 3 
  
  res <- copSTModelSelect_cpp(x, y, ct, K, n, ModelCnt, B, maxit1, maxit2, add_penalty, Message_prog, 
                               Message_res, std_err, eps)
  regres_par <- matrix(res$main, (K + 1), K)
  
  ret_est <- list("intercept" = regres_par[1, ], "main_effects" = regres_par[-1, ], 
                  "correlations" = res$rho)
  ret_v <- res$v
  
  if(std_err){
    se <- rep(0, length(ret_v))
    se[ret_v == 1] <- sqrt(res$std_err)
    se_main <- matrix(se[1:(K * (K + 1))], (K + 1), K)
    ret_se <- list("intercept" = se_main[1, ],
                   "main_effects" = se_main[-1, ], 
                   "correlations" = se[-(1:(K * (K + 1)))])
    
    return(list( "coefficients" = ret_est,
                 "likelihood" = res$likelihood, "selected_model" = ret_v, 
                 "standard_error" = ret_se))
  }else{
    return(list("coefficients" = ret_est,
                "likelihood" = res$likelihood, "selected_model" = ret_v))
  }
}