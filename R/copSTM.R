#' Fitting copula-based Multivariate spatio-temporal model
#'
#' \code{copSTM} fits a Gaussian copula-based model on grouped spatial-temporal lattice data. 
#' Data is assumed to be observed on an \code{n} by \code{n} lattice. 
#' Observation in each tile could be multivariate, with dimension K. 
#' It is required that \code{length(y)/(K*n^2)} is an integer. 
#' If data is temporal, this is considered as the number of time points,
#' otherwise, the number of independent samples. 
#' 
#'
#' @param x A matrix of covariates, 
#' needs to be generated by \code{make_data} or \code{sim_data} if \code{temporal} == TRUE, 
#' otherwise could be any matrix.  
#' @param y A vector of count data response. 
#' Required to be organized as 
#' \eqn{(y_{i, t, k}) = (y_{1, 1, 1}, \dots, y_{1, 1, K}, y_{2, 1, 1}, \dots, y_{2, 1, K}, 
#' \dots, y_{n^2, 1, K}, y_{1, 2, 1}, \dots, y_{n^2, T, K})}, 
#' where \eqn{(i, t, k)} denotes the indice of tile, time point and group respectively. 
#' @param K The number of groups.
#' @param n An integer number, the image is tilled into n*n grids.  
#' @param marginal Marginal distribution: "pois" for Poisson, "nbinom" for negative binomial. 
#' @param cor_type Correlation type. 
#'  \itemize{
#'  \item \code{sp}: Spatial only, consider only correlation of the same group from neighbouring tiles,
#'  \item \code{mv}: Multivariate only, consider only correlation between different groups in the same tile,
#'  \item \code{both}: Both "sp" and "mv", as well as between-group correlation from neighbouring tiles,
#'  \item \code{ind}: Independent, \code{copSTM} is equivalent to GLM, please enter K = 1 and n = 1.
#'  }
#' @param temporal Logical, if the data should be treated as temporal data. 
#' If TRUE, the output of regression coefficients takes the form of a K by K matrix, see \code{\link{idpSTM}} for details. 
#' Also the computation of standard errors requires bootstrapping, see argument \code{std_err} for details.  
#' @param maxit Maximum number of iterations of maximum likelihood estimation (default 100). 
#' @param eps Convergence threshold for maximum likelihood estimation (default 0.1). 
#' @param std_err Logical, if TRUE returns standard errors of all parameters. 
#'  If \code{std_err == TRUE && temporal == TRUE}, standard error estimation requires bootstrapping, 
#'  therefore, user needs to specify the bootstrap sample size \code{B}. 
#' @param B The number of bootstrap samples to be generated for computing the standard error of parameters (default 100).
#'          Required only when \code{std_err == TRUE && temporal == TRUE}.
#' @param Message_prog Logical, if TRUE, prints messages indicating progress. 
#' If \code{std_err == TRUE && temporal == TRUE}, computational time is expected to be much longer than \code{std_err == FALSE}, 
#'  (depend also on the size of \code{B}), Therefore in this case, it is recomended to set \code{Message_prog} to be TRUE, 
#'  
#'
#' @return A list with components
#' \itemize{
#' \item \code{likelihood:}   Maximized log-likelihood. 
#' \item \code{coefficients:} A list of parameter estimates: 
#'                     \itemize{
#'                       \item \code{intercepts:}  A separate intercept for each group,
#'                        \item \code{main_effects:}  Regression coefficients,
#'                        \item \code{correlations:} Spatial and multivariate correlations of observations at the same time point, 
#'                         \item \code{dispersion:} Overdispersion parameter, returned only when \code{marginal == "nbinom"}. }
#' \item \code{standard_error:}  A list of estimated standard errors, in the same format as \code{coefficients}. Returned only if \code{std_err == TRUE}. 
#' }
#'
#' @examples
#' ### Ex1. 
#' K <- 2
#' n <- 10
#' t_size <- 10
#' true_beta <- c(-1, 1, 0.5, -0.5, 0, 1) # i.e. Intercept: -1, -0.5
#' true_rho <- c(-0.3, 0, 0.3, 0)
#' sim_dat <- sim_data(n, K, temporal = TRUE, t_size, marginal = "pois",
#'                     true_beta, true_rho, cor_type = "both")
#' # in the same form returned by make_data
#' est1 <- copSTM(sim_dat$covariates, sim_dat$response, K, n, marginal = "pois",
#'                cor_type = "both", temporal = TRUE, maxit = 50,
#'                std_err = FALSE) 
#' cat("\n true regression coefficients: ", c(matrix(true_beta, K+1, K)[-1, ]), "\n", 
#'     "estimated regression coefficients: ", round(est1$coefficients$main_effects, 2), "\n\n", 
#'     "true correlation parameters: ", true_rho, "\n", 
#'     "estimated correlation parameters: ", round(est1$coefficients$correlations, 2))
#' 
#' ### Ex2. 
#' true_rho <- 0.3
#' sim_dat <- sim_data(n, K, temporal = TRUE, t_size, marginal = "pois",
#'                     true_beta, true_rho, cor_type = "mv")
#' est2 <- copSTM(sim_dat$covariates, sim_dat$response, K, n, marginal = "pois", 
#'                cor_type = "mv", temporal = TRUE, maxit = 50,
#'                std_err = TRUE, B = 30, Message_prog = TRUE)
#' cat("\n true regression coefficients: ", c(matrix(true_beta, K+1, K)[-1, ]), "\n", 
#'    "estimated regression coefficients: ", round(est2$coefficients$main_effects, 2), "\n\n", 
#'     "true correlation parameters: ", true_rho, "\n", 
#'     "estimated correlation parameters: ", round(est2$coefficients$correlations, 2))
#' print(est2$standard_error)
#' 
#' ### Ex3. 
#' true_rho <- c(0.3, 0.5)
#' dispersion <- 1
#' sim_dat <- sim_data(n, K, temporal = FALSE, t_size = 1, 
#'                     true_beta, true_rho, cor_type = "sp", 
#'                     marginal = "nbinom", dispersion = dispersion)
#' est3 <- suppressWarnings(copSTM(sim_dat$covariates, sim_dat$response, K, n, marginal = "nbinom",
#'                                 cor_type = "sp", temporal = FALSE, maxit = 100,
#'                                 std_err = FALSE) )
#' cat("\n true regression coefficients: ", c(matrix(true_beta, K+1, K)[-1, ]), "\n", 
#'     "estimated regression coefficients: ", round(est3$coefficients$main_effects, 2), "\n\n", 
#'     "true correlation parameters: ", true_rho, "\n", 
#'     "estimated correlation parameters: ", round(est3$coefficients$correlations, 2), "\n\n", 
#'     "true dispersion parameter: ", dispersion, "\n",
#'     "estimated dispersion parameter: ", round(est3$coefficients$dispersion, 2))
#'     
#'     
#' ### with real data (expected around 40s)
#' \dontrun{
#' data("cell_growth_data") 
#' n <- 25
#' dat <- make_data(cell_growth_data, n)
#' K <- dat$K
#' est_cop_real <- copSTM(dat$covariates, dat$response, dat$K, n, marginal = "pois",
#'                        cor_type = "both", temporal = TRUE, maxit = 50, 
#'                        std_err = FALSE)
#' print(est_cop_real$coefficients$main_effects)
#' cor0 <- matrix(NA, K, K)
#' cor1 <- matrix(NA, K, K)
#' diag(cor0) <- 1
#' diag(cor1) <- est_cop_real$coefficients$correlations[1:dat$K]
#' ind_r = K + 1
#' for(i in 1:(K - 1)){
#'   for(j in (i + 1):K){
#'     cor0[i, j] <- est_cop_real$coefficients$correlations[ind_r]
#'     ind_r = ind_r + 1
#'   }
#' }
#' for(i in 1:(K - 1)){
#'   for(j in (i + 1):K){
#'     cor1[i, j] <- est_cop_real$coefficients$correlations[ind_r]
#'     ind_r = ind_r + 1
#'   }
#' }
#' print("correlation in the same tile: ")
#' print(round(cor0, 3))
#' print("correlation in neighbouring tiles: ")
#' print(round(cor1, 3))
#' }
#' 
#' @seealso \code{\link{sim_data}}, \code{\link{make_data}}

copSTM <- function(x, y, K, n, marginal, cor_type = "both", temporal = TRUE,
                   maxit = 100, eps = 0.1, std_err = F, B = 100, Message_prog = F){
  
  if(temporal && std_err && !(B > 0)){
    stop("positive B required")
    return(NULL)
  }
  
  if(cor_type == "sp") ct <- 1
  if(cor_type == "mv") ct <- 2 
  if(cor_type == "both") ct <- 3 
  if(cor_type == "ind") ct <- 4
  
  marginal <- which(c("pois", "nbinom") == marginal)
  
  res <- copSTM_cpp(x, y, marginal, temporal, ct, K, n, maxit, eps, std_err, B, Message_prog)
  
  if(temporal){
    regres_par <- matrix(res$main, (K + 1), K)
    
    if(ct == 4){
      ret_est <- list("intercept" = regres_par[1, ], "main_effects" = regres_par[-1, ])
    }else{
      ret_est <- list("intercept" = regres_par[1, ], "main_effects" = regres_par[-1, ], 
                      "correlations" = res$rho)
    }
    
  }else{
    
    ret_est <- list("intercept" = res$main[1], "main_effects" = res$main[-1])
    
    if(ct != 4) ret_est$correlations <- res$rho
    
  }
  
  if(marginal == 2) ret_est$dispersion = res$dispersion

  if(ct == 4){
    
    return(list("likelihood" = res$likelihood, 
                "coefficients" = ret_est, 
                "standard_error" = sqrt(res$std_err)))
  }
  
  if(std_err){
    
    se <- sqrt(res$std_err)
  
    if(temporal){
      se_main <- matrix(se[1:(K * (K + 1))], (K + 1), K)
      ret_se <- list("intercept" = se_main[1, ],
                     "main_effects" = se_main[-1, ])
      
      if(marginal == 1){
        ret_se$correlations <- se[-(1:(K * (K + 1)))]
      }else{
        ret_se$correlations <- se[(K * (K + 1) + 1) : (length(se) - 1)]
        ret_se$dispersion <- se[length(se)]
      }
      
    }else{
      
      se_main <- se[1:ncol(x)]

      
      if(marginal == 1){
        se_rho <- se[-(1:ncol(x))]
      }else{
        se_rho <- se[-c(1:ncol(x), length(se))]
      }
       
      ret_se <- list("intercept" = se[1], "main_effects" = se_main[-1], 
                     "correlations" = se_rho)
      
      if(marginal == 2) ret_se$dispersion <- se[length(se)]
                    
    }
    
    return(list("likelihood" = res$likelihood, 
                "coefficients" = ret_est, 
                "standard_error" = ret_se))

  }else{
    return(list("likelihood" = res$likelihood, 
                "coefficients" = ret_est))
  }
}


#' Model selection of copula-base multivariate spatio-temporal model
#' 
#' \code{copSTMSelect} finds the best model among all possible models. 
#' Models are fitted with \code{copSTM}, 
#' marginal distribution can be specified as Poisson or Negative binomial. 
#' Models are ranked with the composite likelihood BIC (CL-BIC) proposed by Gao and Song (2010). 
#' The best models are found using a Gibbs samplling method
#' introduced by Qian and Field (2002), which allows very large candidate sets to be adressed.
#'
#' @param x A matrix of covariates, 
#' needs to be generated by \code{make_data} or \code{sim_data} if \code{temporal} == TRUE, 
#' otherwise could be any matrix.  
#' @param y A vector of count data response. 
#' Required to be organized as 
#' \eqn{(y_{i, t, k}) = (y_{1, 1, 1}, \dots, y_{1, 1, K}, y_{2, 1, 1}, \dots, y_{2, 1, K}, 
#' \dots, y_{n^2, 1, K}, y_{1, 2, 1}, \dots, y_{n^2, T, K})}, 
#' where \eqn{(i, t, k)} denotes the indice of tile, time point and group respectively. 
#' @param K The number of groups.
#' @param n An integer number, the image is tilled into n*n grids. 
#' @param temporal Logical, if the data should be treated as temporal data. 
#' If TRUE, the output of regression coefficients takes the form of a K by K matrix, see \code{\link{idpSTM}} for details. 
#' Also the computation of standard errors requires bootstrapping, see argument \code{std_err} for details.  
#' @param marginal Marginal distribution: "pois" for Poisson, "nbinom" for negative binomial. 
#' @param cor_type Correlation type. 
#'  \itemize{
#'  \item \code{sp}: Spatial only, consider only correlation of the same group from neighbouring tiles,
#'  \item \code{mv}: Multivariate only, consider only correlation between different groups in the same tile,
#'  \item \code{both}: Both "sp" and "mv", as well as between-group correlation from neighbouring tiles,
#'  \item \code{ind}: Independent, \code{copSTM} is equivalent to GLM, please enter K = 1 and n = 1.
#'  }
#' @param ModelCnt The number of models to be generated via Gibbs samplling (default 100).  
#' @param B  The number of bootstrap samples to be generated for computing the penalty in CL-BIC and standard error of parameters.
#' @param maxit1 The maximum number of iterations of maximum composite likelihood estimation for full model (default 50).
#' @param maxit2 The maximum number of iterations of maximum composite likelihood estimation for sub-models,
#'  expect to be much smaller than maxit1, since submodels take estimates from the full model as initial values (default 10).
#' @param add_penalty A tunning parameter to enforce sparsity. The larger this value is, the more favorable a sparse model becomes. 
#' @param Message_prog Logical, if TRUE, prints messages indicating progress. (Suggest on if long computational time is expected)
#' @param Message_res Logical, if TRUE, prints the top 5 most frequently generated models. 
#' @param eps Convergence threshold for maximum likelihood estimation (default 0.1). 
#'
#' @return A list with components
#' \itemize{
#' \item \code{likelihood:}   Maximized log-likelihood. 
#' \item \code{coefficients:} A list of parameter estimates: 
#'                     \itemize{
#'                       \item \code{intercepts:}  A separate intercept for each group,
#'                        \item \code{main_effects:}  Regression coefficients, 
#'                        \item \code{correlations:} Spatial and multivariate correlations of observations at the same time point, 
#'                        \item \code{dispersion:} Overdispersion parameter, returned only when \code{marginal == "nbinom"}.}
#' \item \code{selected_model:}  A binary vector with 1 indicating selected variables and 0 otherwise.
#' \item \code{standard_error:}  A list of estimated standard errors, in the same format as \code{coefficient}. Returned only if \code{std_err == TRUE}. 
#' }
#' 
#' 
#' @references {
#' X. Gao and P. X.-K. Song. Composite likelihood bayesian information criteria for model selectionin 
#' high-dimensional data.Journal of the American Statistical Association, 105(492):1531–1540,2010.
#' }
#' 
#' @references {
#' G. Qian and C. Field. Using mcmc for logistic regression model selection involving large
#' number of candidate models. In Monte Carlo and Quasi-Monte Carlo Methods 2000, pages 460–474. Springer, 2002.
#' }
#' 
#' @examples
#' \dontrun{
#' ## Ex1.
#' set.seed(444)
#' K <- 2  # number of groups
#' n <- 10 # (squared root of) number of tiles
#' t_size <- 10 # number of time points
#' true_beta <- c(-1, 1, 0.5, -0.5, 0, 1)
#' true_rho <- c(-0.3, 0, 0.3, 0)
#' sim_dat <- sim_data(n, K, t_size, true_beta, marginal = "pois", 
#'                      temporal = TRUE, rho = true_rho, cor_type = "both")
#' # generate data in the same form returned by make_data
#' 
#' MdCnt <- 50
#' B <- 20 
#' gm <- 0.5  
#' set.seed(444)
#' start <- Sys.time()  # expected less than 2 mins 
#' select_est <- copSTMSelect(sim_dat$covariates, sim_dat$response, K = K, n = n, 
#'                             marginal = "pois", temporal = FALSE, cor_type = "both", 
#'                             ModelCnt = MdCnt, B = B, add_penalty = gm,
#'                             Message_prog = TRUE, Message_res = TRUE, eps = 0.1)
#' finish <- Sys.time()
#' print(finish - start)
#' as.numeric(as.logical(c(true_beta, true_rho)))
#' }
#' 
#' \dontrun{
#' ### Ex2. (expect 3 mins)
#' start <- Sys.time()
#' set.seed(444)
#' K <- 2  # number of groups
#' n <- 10 # (squared root of) number of tiles
#' t_size <- 50 # number of time points
#' true_beta <- c(1, 0.8, -0.6, 0.4, 0, -0.2)
#' true_rho <- c(-0.3, 0, 0.3, 0)
#' dispersion <- 1
#' sim_dat <- sim_data(n, K, temporal = FALSE, t_size, marginal = "nbinom",
#'                     dispersion = dispersion, true_beta, true_rho, cor_type = "both") 
#'                     
#' MdCnt <- 20
#' gm <- 0.5 
#' start <- Sys.time()  # expected less than 2 mins 
#' select_est <- copSTMSelect(sim_dat$covariates, sim_dat$response, K = K, n = n, 
#'                             marginal = "nbinom", temporal = FALSE, cor_type = "both", 
#'                             ModelCnt = MdCnt, add_penalty = gm,
#'                             Message_prog = TRUE, Message_res = TRUE)
#' finish <- Sys.time()
#' print(finish - start)
#' as.numeric(as.logical(c(true_beta, true_rho, 1)))
#' print(select_est$coefficients)
#' }
#' 
#' @seealso \code{\link{sim_data}}, \code{\link{make_data}, \code{\link{copSTM}}


copSTMSelect <- function(x, y, K, n, temporal, cor_type, marginal = "pois",
                         ModelCnt = 100, B = 0, maxit1 = 50, maxit2 = 10, 
                         add_penalty = 0, Message_prog = TRUE, Message_res = TRUE, eps = 0.1){
  
  if(temporal && B <= 0) stop("Positive B required")
  if(cor_type == "sp") ct <- 1
  if(cor_type == "mv") ct <- 2 
  if(cor_type == "both") ct <- 3 
  if(cor_type == "ind") stop("copSTMSelect does not provide independent version, please use idpSTMSelect instead")
  marginal <- which(c("pois", "nbinom") == marginal)
  
  res <- copSTModelSelect_cpp(x, y, ct, K, n, marginal, temporal, ModelCnt, B, maxit1, maxit2, 
                              add_penalty, Message_prog, Message_res, eps)
  # estimates
  if(temporal){
    regres_par <- matrix(res$main, (K + 1), K)
    ret_est <- list("intercept" = regres_par[1, ], "main_effects" = regres_par[-1, ], 
                    "correlations" = res$rho)
  }else{
    ret_est <- list("intercept" = res$main[1], "main_effects" = res$main[-1], 
                    "correlations" = res$rho)
  }
  
  if(marginal == 2) ret_est$dispersion <- res$dispersion
  
  # std_err
  ret_v <- res$v
  se <- rep(0, length(ret_v))
  se[ret_v == 1] <- sqrt(res$std_err)
  if(marginal == 2){
    se_od <- se[length(se)]
    se <- se[-length(se)]
  }
  
  if(temporal){
    se_main <- matrix(se[1:(K * (K + 1))], (K + 1), K)
    ret_se <- list("intercept" = se_main[1, ],
                   "main_effects" = se_main[-1, ], 
                   "correlations" = se[-(1:(K * (K + 1)))])
  }else{
    se_main <- se[1:ncol(x)]
    ret_se <- list("intercept" = se[1],
                   "main_effects" = se_main[-1], 
                   "correlations" = se[-(1:ncol(x))])
  }
  if(marginal == 2) ret_se$dispersion = se_od
  
  return(list( "coefficients" = ret_est,
               "likelihood" = res$likelihood, "selected_model" = ret_v, 
               "standard_error" = ret_se))
  
}